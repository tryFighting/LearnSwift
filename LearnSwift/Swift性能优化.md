#  深入剖析Swift性能优化
1.Swift性能提升：
  编译器优化：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化
  开发者：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化
  
  可以通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序
  
  >>>>>>>数据结构:Class,Struct,Enum
  >>>>>>>组件关系：inheritance,protocols,generics
  >>>>>>>方法分派方式可以分为Static dispatch和Dynamic dispatch
  
  ++++++++Allocation,Reference counting,Method dispatch++++++
  --- A----
  Allocation:内存分配可以分为椎区栈区，在栈区的内存分配速度要高于椎，结构体和类在椎栈分配是不同的
  ----Stack:基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于椎区
  -----Heap：高级的数据结构，比如类，分配在椎区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为椎区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此是一种性能消耗
  声明为Class,在椎区初始化时，除了分配属性内存，还有额外的两个字段，分别是type和refCount
  
  内存分配总结：Class在椎区分配内存，进行内存管理，使用了指针，有更大的特性，但是性能较低
  优化方式：对于频繁操作，尽量使用struct替代class，因为栈区内存分配更快，更安全
  
--- B----
对于复杂的结构体，需要管理双倍的引用计数，每次将结构体作为参数传递给方法或者进行直接拷贝，都会出现多份引用计数
引用计数总结：
Class在椎区分配内存，需要使用引用计数器进行内存管理
基本类型的Struct在栈区分配内存，无引用计数管理
包含强类型的Struct通过指针管理在椎区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，Class只会有一份。
 优化方式：
 1.通过使用精确类型，例如UUID替代String,这样可以进行内存内联，在栈内存储UUID，栈内存管理更快更安全，并且不需要引用计数
 2.
 Enum替代String,在栈区管理内存，无引用计数，并且从语法上对开发者更友好
--- C----
Method Dispatch
1.Static dispatch更快，而且静态分派可以进行内联等进一步的优化，使得执行更快速，性能更高
2.Dynamic dispatch 每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，慢于Static dispatch
尽可能使用static dispatch
---------inheritance constraints 继承约束我们可以使用final关键字去修饰Class，以此生成Final Class，使用Static dispatch
----------access control访问控制private关键字修饰，使得方法或属性只对当前类可见，编译器会对方法进行static dispatch

总结：Swift提供了更灵活的struct,可以在内存，引用计数，方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更加快与安全


2.延伸
Struct实现多态，答案是protocol oriented programming

Protocol Type-----(如何存储和拷贝变量，方法派发)
